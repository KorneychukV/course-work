1. Чтобы всё запустить нужно просто сделать: docker compose up

2. Вместе с keyacloak нужно поднять БД для него (она уже есть в композе)

3. После запуска нужно создать realm (королевство :D) в котором будет храниться информация для аутентификации
3.1 В нём создаём клиент - это область аутентификации для нашего приложения. В одном королевстве может быть несколько клиентов, чтобы разные приложения могли работать.
3.2 Для клиента создаём роли и пользователей. Пользователя задаём необходимые роли, а также логины и пароли.

4. В приложении добавляем зависимости:
		
    <dependency>
      <groupId>io.quarkus</groupId>
      <artifactId>quarkus-oidc</artifactId>
    </dependency>
    <dependency>
      <groupId>io.quarkus</groupId>
      <artifactId>quarkus-keycloak-authorization</artifactId>
    </dependency>
    <dependency>
    
5. Помимо этого, нашему приложению нужно указать где находиться keycloak и с каким его клиентом мы работаем. Это делается в application.properties:
	quarkus.oidc.auth-server-url=${KEYCLOAK_URL:http://localhost:8082}/auth/realms/prof
	quarkus.oidc.client-id=app-auth

6. Чтобы наши endpoint были под защитой keycloak, нужно всего лишь навесить на них аннотацию, которая говорит, какие роли могут обратиться к нашему приложению:
	@RolesAllowed({"default-roles-prof"}) - доступно только для пользователей с ролью default-roles-prof
	
7. Как это всё работает:
7.1 Пользователь заходит в приложение (фронтенд), нажимает "Вход" и его перенаправляет на страницу аутентификации.
7.2 Он вводит данные для входа, после чего keycloak присылает access_token и refresh_token (прочитай про это сам, поймёшь, что это).
7.3 При обращении к endpoint на нашем микросервисе, если он помечен @RolesAllowed, делается запрос в keycloak с полученным access_token.
7.4 Если всё хорошо (пользователь имеет доступ - авторизован), то запрос выполняется.
7.5 Если всё плохо (пользователь не имеет доступа - не авторизован), то возвращается ошибка с кодом 401.
